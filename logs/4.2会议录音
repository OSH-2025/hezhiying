说话人1 00:00
原文：
我先简单介绍我这几段时间查到的信息，就是说你录的是吧，我就不录了。是录的吗？录的那就好，有语音转文字，
说话人2 00:11
原文：
我好像没有，你可以用腾讯会议，然后聊一下我有会员，
说话人1 00:17
原文：
可以我们要做什么。大概情况是这样子的，就是我了解到的一些情况，我们的目标的处理器是stm3f103、GT6，它的flash你可以理解为存程序的空间是一兆，然后RAM是96k然后我大概的规划是在96k的空间里面画出32k给系统用，然后剩下64k给用户用。
说话人1 00:49
原文：
然后由于我们的sm32里面是没有所谓的训内存的，它也没有那些保护模式这样的东西，所以的话我们的系统跟用户程序其实是平级的，我们都是一个程序，只不过是我们来负责调度的。
说话人1 01:01
原文：
好，然后具体怎么实现是这样的。首先就是说存用户程序可以存在哪些地方，用户程序可以跟系统，因为我们的系统写完之后就是一对一点c点h的文件，可以这么理解吗？那么当然还有点s汇编文件，就是这一堆东西像一个工程一样，它就是一个工程了，然后当你需要写什么别的你的任务的时候，你要把它写成一个函数的形式，然后把它们两个编译在一起，这样的话用户的代码不就在flash里面了吗？一开始编译在一起用链接器链接好了，所以它就在代码里面。
说话人1 01:39
原文：
所以的话就是第一种方法怎么运行的程序，就是你的程序就是放在flash里面的一个函数，我们只需要在系统启动的时候用一些系统提供的，我们系统会提供一些API，然后你可以直接调 Api来启动一个新的线程，我们启动这个线程之后，它就是你就这么调调了之后，你把你的函数传进去，那么它就会运行起这个函数来，并且自动的完成一些东西切换之类的这些功能，那么这是第一种形式。
说话人1 02:06
原文：
第二种形式就是说ftm32是支持直接在内存里运行代码的，就说你的代码可以是放在内存里面，然后直接把指令直接丢到内存里运行，这也是可以的，这是第二种方式。
说话人1 02:17
原文：
那么第二种方式适合的是什么情况？如果你的代码是属于那种。
说话人1 02:24
原文：
用户现场生成的代码，你懂吗？就这个代码不是一些写好的，甚至比如说传过来的或者等等各种各样的方法，反正过来的直接放在内存里的数据，我们可以把它当代码来执行，这是第二种方法。
说话人1 02:36
原文：
然后然后有一个叫做换入换出的这么一个概念，就是说64k的内存我们可以分成好几块，比如说假设你分成4块，那么就每块不是有16k那么这16k的内存可以拿来干什么？
说话人1 02:53
原文：
第一种就是说你首先要明确一个就是要任务的概念，一个任务是一段代码加上对应的数据，加上它的上下文三部分构成的，然后代码数据加上下文代码，刚才说了它可能存在于flash里面，也可能存在于内存里，然后数据全部都在内存里的，然后它的还有一个上下文，我们是保存在系统的一个就系统的程序里面的有一个数字在里面，专门保存上下文的，那么每次需要调度到这个东西的时候，我们就会要恢复这三者。
说话人1 03:28
原文：
首先把代码和数据准备好，如果这个数据是被换出了的话，就把它换回来，一会我会解释什么叫换出换入。然后还有上下文恢复之后，这个程序就可以正常跑了，对不对？
说话人1 03:41
原文：
然后程序需要进行调度的时候有几种方法，第一种方法就是说它调用系统给它的一个API， Api可以无条件的将当前的系统控制权转交给另外一个正在运行中的任务，比如说我执行了1个这个东西之后，它就会转交，比如说我本来是3有4个线程在运行的，那么我调用我一号线程调用一个这个东西传一个二进去，那么系统就会把一号线程暂停运行，然后把控制权转交给二，然后二继续运行这样子，这是第一种情况。
说话人1 04:13
原文：
第二种情况就是当一个线程已经用完，目前分配给它所有时间的时候，系统会自动的把它收回，转交给另一个，那么这个是怎么实现的？实现方法就是这系统上有个定时器，这个定时器比如说其实就是一个定时器中断，比如说每一毫秒就自动切回来一次，那么每一毫秒切回来的时候，系统就会检查当前现场已经运行了多久了，如果它已经达到达到它所能使用的时间片的上限的时候，它就会自动收回这个线程，并且转交给下一个嗷嗷待哺的线程。
说话人1 04:46
原文：
那么怎么变他那个县城是否嗷嗷待哺还是已经吃饱了，那么每个县城会有一个标志位，不叫标志位，就是有一个数，这个数越大，你可以因为现优先级越高，我们优先调度的优先级高，就优先把控制权转交给优先级高的优先级高的没有事了再转交给低的，然后线程可以标识自己处于2种不同的状态，不处于3种不同的状态，或者说是4种就是算上一些异常的话一共是4种。那么一种是挂了现场不需要微调的。
说话人1 05:17
原文：
第二种是现场处于休眠状态，就是I的状态，I的状态是什么情况？就是这个东西它并不需要被调度，它只是比如说等待某个资源，我们可以不需要被调度。第一种是他直接就挂了，第二种是不需要在目前不需要被调度，可能需要等待某个外部事件把它唤醒。第三种是它处于正常的调度，也就是我们系统中的正常的那种抢占式多任务，就是123这样轮流，然后优先级高的优先级分给他，优先把时间分给他，这是第三种。
说话人1 05:48
原文：
第四种是real time模式，因为我们需要做大面积的任务的话，我们希望有些比如说你有严格时序要求的这种东西，我不希望它被打断怎么办？线程可以临时把自己设置成real time模式，real time模式之后，系统就会保证这个东西一直在运行，不会去打断它，直到他用另外一个函数让他自己他主动告诉系统说我要退出real time了，然后系统就会把它回归到刚才说的第三种状态，就是正常被调动的，那么就是几个线头轮流跑。
说话人1 06:16
原文：
然后接下来什么叫换？换？出的意思是当你这个线程，比如刚才不是说你的内存，你不是64可以装4个线程对不对？如果某个线程说我现在不想干了，怎么办？可以的，系统可以把线程换出，也就是说把线程从内存中把它丢掉，丢到哪去？
说话人1 06:40
原文：
我们刚才不是说了我们有外部存储，就是我们单片机还外挂一个容量很大的内存，可以把它存到那里面去，但那个有一个缺点，那个地方的代码是不能直接被执行的，它必须还得读进单片机内存里才能被执行，虽然那个地方在单片机看来就是内存空地址空间中的一段，就是因为我们算sm32有一个非常有意思的功能叫fsfsmc外部的静态内存控制器，那么它可以直接把一个接在片外的什么？
说话人1 07:09
原文：
映射到单片机自己的地址空间中的一段，你知道什么是地址空间吗？你好像可以用一个指针那样访问，它就可以直接访问，不需要走正常的，比如正常你外设挂了一个存储器，你怎么你每次要往两个端口上把你的地址写出去，把你的那些比如说写入写入使能读取使用等这些信号都设置好，然后读一下，然后再怎么样，那么每次你不就得执行好几步，但是fsmc这个东西可以直接把你的一段内存就内存地址就直接映射到这个内容这个存储器上，那么你就可以直接就像访问一个正常的内存一样访问，它不需要经过刚才我说的单面机会，硬件会帮你处理好，就是一些时序上的问题，那么可以把它换出，那同理会有换入，如果某个系统需要被调入，那么就会需要有一个copy的动作把它copy到里面来。
说话人1 07:57
原文：
为什么不能经常换入换出这样这个过程很慢，因为你每次都要复制16k的东西进来，虽然我们说有DNA可以帮助我们解决这个问题，就缓解这个问题，但我们一开始写程序就不去用DNA了，直接应付治理的话就是读一个字典，写一个字典，读一个字典，写一个字典，这么长也花不了多少时间，16k的话可能可见应该是小于一毫秒，所以其实也没有什么关系是换进来换出去，当一个线程你设定一个规则，比如说当一个线程在连续10次调度都没有被调度上，那么就可以把它换出了。
说话人1 08:29
原文：
当前有一个比它更紧要的事情，并且这个东西已经10次没有被换出了，那么就可以怎么被我丢出去，然后就可以把1个更紧要的东西换进来，因为我们这总共4个可以被动，我们真正能被调过去只有4块对不对？
说话人1 08:46
原文：
然后我们再接下来是什么？我们说了我们不是没有虚拟内存，我们没有虚拟内存的情况下，怎么实现每个线程都只能访问自己，不叫只能访问了。
说话人1 08:56
原文：
我们是相信写线程的人不会去越界访问别人的东西怎么办？就是每个线程他的首先它的栈一定是位于这16个k的空间里面的，我们一开始这个阶段可以不考虑把代码放到这个里面这种情况，因为在单片机上一般来说代码都是写死的，很少有人说动态生成一段代码用到内存就好，这个情况少见，所以我们初期阶段我们可以不考虑这个情况，那么就认为所有代码都在flash里面，所有数据都在占都在内存里怎么办？
说话人1 09:27
原文：
单片机不是，你的程序在运行的时候有两个需要维护的数据区域，一个叫做站，另一个叫堆，这都明白吧？我应该都明白吧？
说话人1 09:38
原文：
站区域是程序的函数，调用局部变量等等，还有非区域，当然我们说其实它有全局变量，但是我们禁止线程自己创建全局变量，就是我们认为这个线程必须只能在自己的站里面维护，你说怎么创建全局变量没问题，你可以用系统的API告诉系统，我需要一个全局变量多大，那么系统会在系统区的32k里面给你分配内存，你就以后都用这个地址去访问，那么就可以保证线程不会有自己的全局变量，也就系统也就换句话说，系统只需要维护这16k点就行了，外面的我不用管了，我就系统可以自信地认为说我只要把这系统可以复制走，下次再复制回来，那么现在我们回到刚才的状态，
说话人2 10:21
原文：
我们就可以自信的认为这一点好吧？
说话人2 10:24
原文：
如果。
说话人1 10:24
原文：
我需要两个线程共享一个变量没关系，你只要要一个系统API告诉他，比如我要16个字节的共享变量，那么系统就会给你返回一个地址，如果他还有地还有空间的话，就返回一个地址给你，那么这个地址的话你可以传给各个线程了，因为大家都知道它就是那个地方的东西，那么同时系统会在自己的表里面记上一笔说有哪个线程在什么时候给我分配了这么多内存，起始地址是多少，那么线程销毁的时候我们会自动的把这个区域归还，如果你不归还那不就完了，如果内存有一个进程，它的有内存泄露怎么办？他每次都分配那么一点回去好了，他退出他又忘了换，于是那个系统突然就占满了，这肯定是不行的。
说话人1 11:01
原文：
没关系，我们可以用一个外部的注册系统里面有个表进行谁分配了什么，以后当我们要终止这个事情的时候，就当某个线程不管是自己挂了，别人挂了还是系统把它给弄挂了没关系，我们只要这个表里面寻找一遍刚才挂的线程到底分配哪些东西把它归还就行了，所以的话这是这个情况。
说话人1 11:26
原文：
还有就是一个县城它一旦叫什么，它一旦启动之后，我们就认为它的那些局部变量里面已经包含了地址，因为这个地址其实是绝对地址，所以的话我们不能直接的去让线程运行在不同的全派里面走了，原来在一号区域，原来在内存里是一号区域运行的现场，以后也只能在一号区域运行，这是原因是什么？原因是假设他跑到二号区域，原来他离县城周边也可能有些指针指针可能还指向一号县城，原来一号的数据空间里的东西怎么办？肯定不行对不对？
说话人1 12:07
原文：
所以我们就要求你必须你里面的这些指针，
说话人2 12:13
原文：
你。
说话人1 12:15
原文：
指到这个位置上去了，那么就是系统不能去改用户的这些东西没关系，我们可以让现场始终只在一号这个空间上跑，反正他哪个空间对他来说是对等的，对不对？但这个情况需要避免一种什么事情？
说话人1 12:29
原文：
就是说如果创建的时候，如果你都把现场都塞在一号空间肯定不行，那么一号空间很快塞了1个，第二个只能放在后背，就是放在片外的这种武器里的，他们俩就不停的交换，然后3234全是空的，这可不行，最后我们创建的时候可能什么就在这4个县城里面。
说话人1 12:46
原文：
那么这4个空间里面寻找1个最短的就是在上面排队的线程数量最短的这么1个区域，把新的系统创建区域里面，然后在每1个区域里面单独的进行调度，你不能把一个原来处于一号的地方的东西直接叫做二号，这是不行的，因为就算二号线是很空的也不行，为什么？因为你一旦要调度的时候，你就设计用户空间里面的这些指针都要被跟着改到那个地方去，为什么要改？现在又回到刚最开始的话，你就sm上没有那层管理，换句话说所有的地址都是绝对地址，没有说我们说通过一个有个地址转换表把它转换到库里面，这个功能它没有，那没关系，我们就直接把它做就行了。
说话人1 13:29
原文：
然后这是第一种模式。
说话人1 13:30
原文：
还有第二种模式就是我们所有的线程共享了64k的空间，但是64k空间是由片外的存储器映射过来的形成，就是说我们每次交换的时候，我们完整的把这64k全部放到写片外，然后再从片外里面拿出64k来，就另一个现成的64k数据去拿过来放到这个里面，我每次都会发生一个64k的交换，交换时间其实也很短，通常来说的话 Stm32有72兆的，它大概假设能够一秒钟的一一兆的指令的话，62 64k其实相对来讲其实是十几毫秒的时间，我们还一定程度还能接受的。
说话人1 14:13
原文：
所以的话但其实肯定不止没变化，你造条指令你有 DNA不是高速交换对吧？啪一下就搞完了，所以就没关系，这个都是后话，就是第二阶段我们要实现的，当然第一阶段我们知道很原始的，4个区域独立的进行调度，第二阶段就是我们每个县城都拥有自己独立的64k的那么大内存，一旦它需要调度的时候，我们是直接把整个64k都搬走再搬回来。
说话人1 14:39
原文：
那么因为所有现成的共享这一块，所以就没有我们刚才说的地址，会可能被多个不同东西复用这个问题。
说话人2 14:46
原文：
怎么样？
说话人1 14:47
原文：
刚才我的意思是说，因为每个线程它只能在这4个里面选1个，那就可能带来1个效率低下，比如说突然之间所有的3号3号slot里面的线程等待时间都加长，那么就导致三号这转的就不利索，本来明显看到隔壁二号其实是空的，但你也不能把三号楼转到二号去，为什么？
说话人1 15:07
原文：
因为他们的三号里面有些指针可能还指向三号的地址，你就在线程不知情的情况下，直接把它搬到了二号去，那一会儿在线程再恢复的时候，他还拿着原来三号的指针去指三号里面的数据，那肯定受不了。
说话人1 15:20
原文：
所以的话因为系统不知道用户在哪些地方放的是指针，他也不可能帮用户去更新这件事情，所以这是第二种方法，就是你刚才说的第一种。第一种就是4个轮流的，4个单4个分别进行调度。
说话人1 15:33
原文：
第二种是一块共用的64k数据区，大家共用它每一次都发生了一次交换，第三种情况是什么？第三种情况是我们都不这么做了，我们沿用一的那种内存布局，4块区域分别是44就4个不同的现场，但是我们分配区域的时候不是之前那么简单，我们规定比如说1号区域是始终给那些优先级最高的2号区域中间，然后去给政府的4号区间，那么的话就是同一个内存区域里的线程优先级都比较固定的，相对来讲调度效率会高一点，我们所判断系统的一些情况，你用户在创业前会指出它的优先级是多少一个数，越高的就是优先级越大，比如说假设我们约定它的0~100，我就认为是0~25的是一种，25~50是一种，就这样子。
说话人2 16:29
原文：
好，然后你说因为用户只能全是0~25，
说话人1 16:34
原文：
什么问题谁知然后。
说话人2 16:39
原文：
你说你要是高度面积都没跑完，那不是，你如果把它强制分成1234，按高低优先级来评价，如果高高的占的时间比较长，对吧？他们一定能完成，他就应该为你赚，难道不是你后面另外现场就形成了，
说话人1 17:02
原文：
不是你高优先级的，没有高优先级还有没有处理完的东西，其实优先级是不会影响的。
说话人2 17:09
原文：
但是你们4个县城可以按高低排，对我高温天气没运行完，我还要运行1个高温天气，
说话人1 17:20
原文：
那就会被排到高温气的后面。
说话人1 17:22
原文：
它们之间除了没有运行完这种状态，你刚才说那是非抢占式的，因为还有一种叫抢占式的，就是你没运行完这么抢占。
说话人2 17:30
原文：
你就不太对，为什么？明明人家高分低，但是后面二三十台跑的比他低优先级的线程，这不是。
说话人1 17:38
原文：
这没有他没在跑，他同时只能调动一个线程要看什么呢？你不是说高的在，因为你只有一个核心，同时只能执行一个现场，你懂吗？我瞎操作没有，
说话人3 17:51
原文：
那到时候比如说只有大吗？还是。
说话人1 17:54
原文：
什么其他状态都是用户指定的，所有的优先级都是用户截图，就我们充分的相信这个用户你懂吗？因为其实这个用户就是我们自己用的对吧？就是写程序人一起写进去，所以说所有的状态都是由用户指，当然我们刚才说这个模式三可能多少显得有点就是太极端了，这个是一定这是另一种情况。
说话人1 18:14
原文：
还有第四我还考虑过第四种模式就是说你不是有那么多有4个区域对不对？你不是有4个区域，然后每次当你需要申请内存的时候，我们叫什么？我们系统帮你申请，不要你不是有这么大的一个空间节目对不对？那么你在所有需要指针操作的地方，都用一个函数把它rap一下包裹一下，那么就是系统每次需要进行指针操作的时候，就自动的根据这个函数所给出的地址，把它进行一个地址的调整。
说话人1 18:56
原文：
比如说你原来在一号，那么你正常来说你现场里面你这么多个数据结构里面记录是不是都是一号的地址，等一会系统把你调入到二号这个地方的时候，你还用原来一号地址去去执行那些东西肯定不对了，对不对？
说话人1 19:09
原文：
但是如果你的指针外面都有一个rap的话，系统就会知道你第一次创建在哪里，假设你被搬到了第二行区域，它就自动给你内存之后，地址都就你每当你要访问内存的时候，都在你地加上某个特定的数量，这样的话就保证了就是说你访问的就是二号，就是把一号原来就是等距离的这种迁移到了二号里去的，这样的话带来一个问题就是内存访问速度会降低的条件。
说话人3 19:34
原文：
会用不都是除了中间映射这一步。
说话人1 19:38
原文：
映射不要耗时间吗？
说话人1 19:40
原文：
难道这一步会很耗时间，尤其是你高频举个例子，刚才讲复制数据那种就是一个循环不停的写读写，所以每次都要回到系统的重新找一个表，找到这个表中的某一项，然后再计算偏移，然后再把这两个相减打回去肯定很耗时间，其实。
说话人1 19:59
原文：
好这是第二种方法。
说话人1 20:00
原文：
还有第五种方法就是硬件，me我们在外设做一个硬件，所有的现场不使用644k的空间了，我们全部去使用外设的空间，就是你外设不片外不是有一个s有个smc，不是连接到一个内存吗？系统内的64k系统内的96k全部给系统用，这是就large模式，系统内的所有的六九十六k空间全部给系统用来维护这些结构，片外的存储器给用户用，你说那片外的数据怎么实现掉，怎么实现多任务的切换，这个时候就不得不谈到smc的 Smc的一个特点，它外片外的存储器，你不用把片外存储器的所有空间去所有地址都先去，地址线全部暴露给芯片，我举个例子，天外存储器比如说它有64k的空间假设，但是我们肯定不止64k我们最后用的是512k的512k和16个字，几十六条数据线的就是100 512k一个字，对应的就是一兆字节，知识空间是相当之大的大的离谱，他能做什么呢？
说话人1 21:18
原文：
我就想说了他是这样子的，你不是512k对你不是有1919条那个地址线好办，我19条地址线，我只每一个程序用户程序，我只给他16条，只把这16条接到 ffsmc的控制器的那条线上，那么相当于是这个线程它只能访问16 16条地址线，能寻址的东西也就是64k你说高的三高的三就是987，这三条线给谁用呢？系统用。
说话人1 21:51
原文：
系统只要改变了三个，就可以在内存这么大的空间里面选出其中的一半就是4k的给这种了。
说话人1 21:58
原文：
那么它只要一改，那么它只是一个简单的跟我们之前查找表是一样的道理，直接就改了，这个是零时间消耗的，不需要任何时间消耗就改一下，马上就变成另一个线索，也不需要进行任何的复制，只要改一下这3条线上的数，我就可以在8个空间里面选择1个。
说话人3 22:17
原文：
读外设的速度快吗？
说话人1 22:19
原文：
还可以能到几十兆几十兆每秒，几十兆对几十兆每秒，这速度相当的慢，但是在我每次执行。
说话人3 22:27
原文：
的时候，是不是都需要先从外面拿出来一个，然后再放到系统内存，
说话人1 22:33
原文：
不用，刚才不是说它其实映射到了系统内存空间里了吗？
说话人1 22:37
原文：
它就是你地址走向了一个区域，你就变成了就类似于相当于加了一块内存，对外部的内存，然后用户程序就是一个指针，你就直接访问，就跟正常的访问没有任何区别，直接访问就行，对，那么这样的话我们就可以同时规划出很多块来，也不需要没有任何复制开销，哗的一下直接转一下就过来了，三那三条地址线就可以单体技能同时调度8个线程，每个线程都有64k相当宽裕的空间，每个线程都有64k的空间可以使用。同时那三条线你说那三条线谁来控制？单片机还有那么多r口随便接36就好了，系统每一次只要给三个端口赋个值，三三个配音赋个值，那么它就可以切换到外面那么多个内存空间。
说话人1 23:22
原文：
一段，那么系统在用户程序看来，它其实内存地址你只是那一段，但它可以不停的改内容，因为它背后所对应到的空间地址不一样，不是这就是一个委安而忧，其实是一个假的地址管理单元，但没关系，内测管理没关系，这已经符合我们的要求。所以第五种方案我自己思来想去，我觉得还是个方案最就看起来最合理，因为它完全不需要任何的物质的开销，他就转过来只是三个s线的问题。我直接发到现场，而且我们本来就s三四外省，谁知外设一直都在，我们本来也要用到，但是本来就没法显得略有点准，每次要复制起来的。
说话人1 24:03
原文：
我说这么简单吗？你直接所有用户程序的话都用外面这块不就好了，64k这里面的96k完全留给系统，全部由系统使用，然后系统会给用户产生一大堆的接口，我们都约定就是说所有的接口大家都用小写字缩写，比如说switch就切换到另一个线程，我们就遵循一个 C里面的秘密风格，你10块钱不是c语言保留字是吧？你没法用，那我们就去 swtch在完成了吗？
说话人1 24:35
原文：
然后传进去就是1个整数表示，我要调度到第几号线程，而且你要注意第几号线程跟我们外设，刚才说的内存空间里面8个其实不一样的，为什么不一样？
说话人1 24:47
原文：
我先说第一个为什么不一样？你每个线程有个线程号，我们认为这个线程号是递增的，自单片机开始一直以来都是递增的，那么递增的意味着递增就意味着这个数字是不会重复的，然后系统里面内部有一个表，这个表记录了哪块内，就外面那么外面fsmc连接到的那一堆东西里面的那么多块，每一块对应的是哪个线程号，它有个这样的对应关系，每次切换的时候我们就去查找一下这个表，然后知道我要把高地高位设置上哪个地方，这是一个好处是什么？
说话人1 25:24
原文：
就是个现场号是递增的，那么也就换句话说就意味着信号不会处理，但每个运行周期都不会，这是有好处的。
说话人1 25:32
原文：
假设我们都用32位的整数，反正sm32 32位程序超过68位单位是吧？32位整数超能力的，你就每次给他指定一个序号就可以了，那么这个单位就知道了，每次创建一个线程，比如说比如说之外的括号，入口函数地址逗号传入的参数逗号，然后别的各种各样的设置在后面，反正没关系就是初始化的，返回就是一个int，就int表示当前线头的线头号，然后单片机的主程序就是0号线程这个是不能改的，0号线在干什么？
说话人1 26:09
原文：
0号线就是做一些初始化工作，初始化完了之后，正常来说它应该就是一个死循环，有一个什么？
说话人1 26:15
原文：
那么操操作系统的所有部件都是靠中断实现，就都在中断处理函数里面，并不会就并不是在组函数里，然后用户如果喜欢需要在组函数里加一些东西也没关系，直接加就行了，那么正常来说我们平时是不会调动组函数上的，当所有的线头都调度完了，发现没有多的可调用的时候，那么自然而然就会报到这个组函数上组还可以做一些清理的工作，这都是可以的。
说话人1 26:41
原文：
整个系统所有的系统的组件的调用都是依靠一个一毫秒一次中断，中断每一次触发系统就在这短短的时间里面把所有该处理事处理完，然后返回到用户现场，至于要返回到的是同一个现场，还是另一个现场，取决于它调度状态，比如它调度状态是需要切换到另一个线程，那么系统就会把干什么？
说话人1 27:01
原文：
把当前在中断发生之前现场保存好，保存在哪？保存它60 96k的空间里面，然后保存进去了之后，现在系统就会寻找下一个可被调度的现场，然后从那一堆列表里面找出一个可调用的，然后把它的先查找它所需要的data，就是它的数据是对应的外部存储其中哪个区段，然后把区段地址先复制好，那么在在这一刻开始，系统里面的映射出来的区间已经对应的是新的线程的区间了。
说话人1 27:34
原文：
然后第三步是什么系统找到线程刚上次被保留的，在现场里面包括它所有计算机的值，还包括它的 Pc，把这些东西恢复回去，然后系统用一个中断返回，那么就会回到什么？用户台去了，回到用户台之后，用户他看起来现场并不知道自己被调度了，现场一被恢复在现场看起来自己被中断执行了一段时间，然后又回去了，那么一个线程如何把自己的控制权转交给系统，就是说我们有大量的时间，你会发现都是一个用户需要把自己的优控制权转交给系统，比如说系统中断不叫中断，就系统调用的时候，我们会需要各种各样的方式把自己的控制权转交给系统，那么有两种方式，那么系统会取得控制权，三种，第一种是发生了发生了任何的终端系统都是首先拿到控制权的那一个。
说话人1 28:32
原文：
第二种方式是当然我们的第二种方式其实是第一种方式的，一部分，就是一毫秒的中断，那是一个特殊的中断，就其他的中断在做什么，其他中断都在说，我们说都在做，比如说响应某个外设的请求，然后用户程序不允许自己声明中断，但你可以把你的中断，就你可以用一个函数把自己的某一个函数跟中断关联在一起，系统一旦收到那个之后，就立刻把这个线程设置成real time模式，然后调度到他身上，这样的话就是保证了什么？就是保证了每一个终端都能被尽快的处理。
说话人1 29:09
原文：
然后第三种方式是什么？通过用户程序显示的能力，你哪个那边路上。
说话人2 29:18
原文：
后面特别好，录音没事在做什么呢？录下来了，这能录清吗？
说话人1 29:26
原文：
录清没事继续录还没说完，对不对？第三种方几点了？我打断你半天，没事，我今天讲了半个小时天，这是第三种方式，就是用户显示的调用的一个函数，这时候控制权当然离开了用户了，对吧？因为它显示调用这些函数，它显示的调用的这些系统函数肯定是系统的部分，对不对？你一旦调用这些函数控制权自然就导入系统，那么对一旦进入了系统的空间之后，第一件事就是系统要把中断关掉，把一毫秒中断给我关掉，为什么要关掉？他不然还得记得使我系统该干的事还没干完，又被一个新的一毫秒中断给打断，那可不行。是吧？
说话人1 30:07
原文：
系统要执行东西的时候，它必须是实时的，就是系统执行整个过程不应该被任何的频段打断，不然的话就出问题了，所以系统进入系统的时候做的第一件事情就是把中国关了之后，他只响应那些外部的更紧急的中断，除了他们之外，其他都不会有很好。然后系统然后中断一关，然后做完了之后再把中断开了。
说话人1 30:30
原文：
那么就这个系统就回到刚才一开始那个状态，他又可以响应新的终端，那么以上刚才说的就是三种不同的进入系统，系统线程在运行中别的线程没有运行，不是系统不是线程，系统就是一个函数就一堆函数，这些函数是系统的一部分，所以在他们运行的时候应该避免被其他事情打扰，因为他们的事情不能被打扰，但是系统在运行的时候还有其他代码在里面，没有，就一个核心，你说。
说话人3 30:56
原文：
怎么？
说话人3 30:56
原文：
那系统在运行的时候没有所谓其他外部限制会被打扰，会打扰你吗？
说话人1 31:03
原文：
除了那些更紧急的外部中断，就是比系统优先级更高的外部中断，
说话人3 31:09
原文：
比如说系统优先级是100，然后有一次用户设置了一个120，认为这个。
说话人1 31:14
原文：
系统是没有优先级的，系统只要在做事，别的东西都不能做，但是系统一般来说占用的时间很短，他通常就只是判断一下当时线程有没有够时间够了，一定要到了，他把它转换到另一个去，就这么简单，
说话人3 31:27
原文：
不是这个东西对，就是说每一毫秒系统中断一次，对，
说话人1 31:32
原文：
但是这个一毫秒那系统可能中断一微秒或者是几十十十几微秒，对其他用户线程如果他是不是real time模式的话，他几乎感受不到这个影响，如果他只是做一些简单的算力，你后循环跑了一半被打断10微秒其实也没什么对吧？
说话人1 31:46
原文：
然后只有在什么情况下会有影响，就是有些线程它要求它必须要以及其严格的方式执行一些持续，比如说这个线必须拉高10微秒，我中间不允许有个10微秒的中断没关系，你把自己设置成任何话语权，那么这个时候系统就没有控制权了，那么只有等你这个线程跑完了，把。
说话人3 32:06
原文：
如果他们关掉之后，系统才能重新获得一毫秒，我们。
说话人1 32:11
原文：
就是完全相信用户的，因为如果用户假设不归还的话，那系统就永远不能被执行。对吧？没关系，我们是相信用户的，所以你要保证你每一次掉了没有他们之后这个线程要正确的归还自己的控制权，不然的话你就把系统给搞掉搞走了。
说话人1 32:28
原文：
没关系，我们这时候还有第二种方法，还有另外一个。
说话人3 32:32
原文：
功能叫我知道的就是我好看能够那么看到我们内部设置什么，就是你的系统。
说话人1 32:40
原文：
太久时间没有被正常调度的时候，我们就会有这样的狗来解决了，那么我们要所有线程事先商量一件事情，比如说一个线程处于优碳模式下，时间不能超过多远，
说话人3 32:53
原文：
有用户设置。
说话人1 32:54
原文：
吗？
说话人1 32:54
原文：
有用户设置就是用户可以预估一下自己的没有碳不会超过多久，但你必须指定一个数，这样的话其实我们不叫看门狗，因为看门狗正常的看门狗一旦它触发就直接把整个系统都重置了，但是我们其实是用定时器实现了一个假的。
说话人1 33:11
原文：
用户一旦进入real time模式的时候，要传入一个数告诉系统你自己预期要real time多久，那系统就会把刚才一毫秒的终端设置成你所给定的时间，那么在这么长的时间内，系统只要你不调度的话，它就不会被调度。
说话人1 33:27
原文：
那么如果这么长时间过来，你还没有归还到你用户的，你还没有把自己的状态归还，那么系统就会发现你的现场不对，我可能把你q掉或者可以发送一个信号等等，这样的方法告诉你的事情不对，然后把你的现场挂起来执行另一个对不对？
说话人1 33:45
原文：
我们实现了你其实是实现了一个没有m一u的完整的，基本上现在iOS该有的都有，
说话人2 33:54
原文：
也对前几年都有的。
说话人2 33:57
原文：
现在写了其实不上1.7，为什么吃饭也吃了两个人吃饭不能上网，这是第一个部分。然后第二第二个部分是 Ios。
说话人1 34:09
原文：
的话它是这样子，就是每个线程可以占有一些io资源，同样的道理就是把访问iOS你必须要告诉系统，我不要访问这个io了。
说话人3 34:19
原文：
我现在看到个问题可能跟你刚刚讲的没有关系，我就突然想到了比如说有1个a进程，比如说里面有10个函数，然后我从a进程跳到b进程的时候，是不是我该如何存储告诉程序这个程序 a晋升到第几个函数了，不是。
说话人1 34:41
原文：
一个线程只能一个函数，它最多是递归，然后就一个线有可能感觉只能有一个函数，对你每个线程都有一个入口函数，系统进入了线程就执行这个函数，那么这个函数如果它调用别的函数没关系，反正这些状态都把它占，
说话人3 34:56
原文：
我知道假如这个函数里面有100个加法，然后我们中间打断，然后我们再想跳回来的时候，我们该如何知道它进行到第几个加法，
说话人1 35:07
原文：
比如说你进行100个加法，你是在获取环里面，比如有个9个变量的，I I是不是在内存里？
说话人1 35:13
原文：
行，我就下次把内存恢复过来， I原原来那个值了，
说话人3 35:16
原文：
假如 a1a1a1a1a一一直连续加100次没有用号多少，我们该如何知道它进行到第几个a加一。
说话人1 35:26
原文：
程序指针，程序指针会告诉你执行到哪个位置了，
说话人3 35:30
原文：
类似有个比较大的对。
说话人1 35:33
原文：
 PC会告诉你执行到哪个位置了，
说话人3 35:35
原文：
这个PC我们可以我们该怎么调用，不是怎么。
说话人1 35:39
原文：
调用，是每次系统把它现场打断的时候，应该是中断的方式记录进入到系统，会自动的把PC存在栈上，你只要读一下站就知道执行到哪里，然后这个东西一起保存在里头。每次回去的时候我们要恢复回上次站结构，然后用一句中断返回，那么系统会自动把这些东西全部丢回到县城里去。
说话人2 35:58
原文：
现在就回到刚才你身上非常的长的，你肯定大概思路现成交现场10万块，
说话人1 36:06
原文：
也不叫10万块，叫做schedule，就是被调度的这么一个完全的过程。
说话人1 36:12
原文：
那么一个线程一旦返回之后，然后接下来就问了，假设一个线程挂了就是返回了，怎么办？返回来那就返回来，你一旦返回这个系统，因为你要想你返回的时候，
说话人2 36:24
原文：
你返回到哪了，你。
说话人1 36:27
原文：
不是返回到一个虚无缥缈的地方，你是返回到了系统，因为系统有一个反就是系统，每次调用那个函数的时候，它会给这个函数你让它调盗用一个函数的时候，你是不是要记录一下，比方说返回值不是返回值返回的地址对不对？
说话人1 36:41
原文：
那么你的线程在返回的时候，
说话人1 36:46
原文：
你在创建线程的时候，你给它传入的返回的地址就是系统的某一个憨豆了，比如return看到了，那么这个函数执行执行完了之后，它一旦return的时候就会直接return到系统里面，因为系统有一个函数不是接触了这件事情，然后他就开始执行清理，把这个函数相关的事情给它清理掉，比如说他原来占用了这一块内存，好这块内存就会就被丢掉了，系统把它标记成现在是空前的，像我们现在用就给他分配这一块，那些分配的资源，我们自己把它清除掉，擦屁股把这屁股擦干净了，然后确保不会遗留下一些别的东西了，然后就回去了，那么你就有人就说你刚才那个线程不是有64k的异质空间吗？里面肯定有些各种各样的数据，这没关系，反正下次不是下，对下次不会，所以你知道为什么新建的变量会有那么多奇奇怪怪的数据在里面，就是因为有可能是上一次遗留下来的，没关系，这是第一种情况。
说话人1 37:42
原文：
第二种情况是用户可以在return的时候显示的要求系统要擦除它用掉的数据，可以有一个系统要用告知系统，你要设置把系统一个flag给它设置一下，告诉系统说你像这样子，你要记得在我返回之后帮我把这个东西擦干净了，而不是只是标记成没有它那个物质全部变成0，对就全归0。
说话人1 38:03
原文：
第三种方法是什么？第三种方法是系统里面有一个线程，你可以创建一个线程，这个线程就会自动的在别的线程都没有干活的时候，自动的把那些已经没有人在用的内存区域把它清成0。
说话人1 38:18
原文：
对，这个就跟现在操作系统，像现在操作系统里面类似的一个东西，就是在别人已经没有用到这个东西的时候，自动把它都全部清除了，这样就会保证就是说这个系统始终是比较干净的，因为某个人忘了归还，或者是忘了告知系统要擦除泄露了一些东西。
说话人1 38:34
原文：
举个例子，假设有用户处理，网上有个箭头处理完密码，反正内存里面就会有一段密码，然后回来的时候还忘了当时怎么查，下次就下个线程一进去的时候，就只要把自己内存扫一遍就能扫到这个地方，肯定是不好的，我们要尽力避免怎么办？我们就是设置一个优先级最低的线程，在所有的线程都没有需要被调度的时候就调动它，就把内存空白内存也就没有人用的，内存也给它擦掉，就擦得干干净净，每次进程结束之后是不是还要差一点？
说话人3 39:03
原文：
不用了。
说话人1 39:04
原文：
不用了，线程结束之后插不插取决于他有没有告诉系统他要插，如果不插那就等待某个时间，当空白页面清零的线程被调度的时候把它插除掉。否则的话如果你告诉系统调查，那么这些返回的时候立刻帮你完全不参与PC，俄罗斯也出来了。这是然后这个是第一个事情。
说话人1 39:25
原文：
第二个事情就是内存管理，我们还需要有。
说话人2 39:29
原文：
一些内存管理的事情，因为。
说话人1 39:34
原文：
我们的系统里面肯定是说动态分配内存对不对？所以动态分配内存的时候肯定会遇到一些问题，比如说给你的64k不够用怎么办？虽然一般来说64k很够用，但是有时候也不够用没关系，当然不是有smc，我们把它的高级位转交给另一个存储器，这个存储器是所有的线程共用的，因为它是所有线程共用的，所以所有线程都能看到里面的东西没关系，你不知道它里面是什么，就别给我动它，因为你一旦动可能搞到别人的数据了是吧？
说话人1 40:10
原文：
你可以给要不然你给当前系统多几位内存，其实你可以不搞共享，如果你想搞共享，那么就有个最高位如果是0，那么就表示是每个进程独有的这些东西，如果是一那么所有现场都能看到这个区域，比如说我们有低较低的一个兆的内存是刚才说分成一段一段一段给每个现场的较高的那一段，是一个兆是所有线程共用的，他们可以通过这段东西来高效地交换一些数据，那么对这一段东西我们需要进行管理，你总不能让系统随便你知道吗？
说话人1 40:42
原文：
不然他随便往里写，他也不知道对方别人有没有用，从他们系统里面就会提供类似蛮好的再复印这样的东西，那么你可以要求系统给你在这一段里面分配一个，比如说叫share的项目，现在work到系统说你要分配多长系统在这里面，你早上去交给你，同样有些的费，那么系统就会就把这一段东西标记成没有人用，下次有人用就行了，这段话我决定直接改写063，就类似代码里面有非常成熟的一个很简单的几十行一百一两百就直接把它改起来搞定，
说话人3 41:15
原文：
几乎不用改好吧，就是把但是我们改完之后，如果用户是在windows系统上写的代码，然后放到47532上，
说话人1 41:25
原文：
那不是我说的是Linux系统源代码里面有一段就是拿来管理内存的，他的思想超过了，我们就直接类似用它的类似的原理造一个就行了，
说话人3 41:34
原文：
不用要求很高，效率只要能用就行，其实。
说话人1 41:38
原文：
我自己也写了类似，但我写的效率。
说话人3 41:40
原文：
比较高，我突然有个问题，你刚刚说我们96k是板子上这种整个不是。
说话人1 41:47
原文：
96k是芯芯片内部，芯片内部就是4032的，对，
说话人3 41:52
原文：
然后我们还有一个外部内存，对外部内存是怎么实现，就是一。
说话人1 41:58
原文：
芯片。
说话人3 42:00
原文：
是另外一芯片，对，当然了如果就非我们4个用，其他人想要用的话，还需要再额外整个芯片吗？
说话人3 42:09
原文：
对就是这样。
说话人1 42:11
原文：
Fsmc上挂一个芯片就这么难的，大部分开发板下都有这东西。
说话人2 42:16
原文：
了，都可以去拍照，没空去了单独照过来，我看看本来是。
说话人1 42:20
原文：
板子你上了淘宝搜，好不容易买几十块钱一块的东西，那个东西的好处是什么？不是它不叫自带，它是板子背面会有预留一个焊芯片的位置，月子可以拿来用焊芯片的位置。
说话人1 42:33
原文：
其实很简单，用起来它是比较方便的，你可以直接往上一装，他直接已经被连到了系统的 Smc的控制系统，然后你创建工程时候设置一下，我需要用这个功能它就给你生成什么。
说话人1 42:49
原文：
然后这是第二种，就是我们说的内存管理，其实需要做的事情基本上是线程自己的事情，他自己处理，我们管不着是吧？
说话人1 42:58
原文：
单片机本来写程序就这么自由的，你很难管得到没关系，这不需要管，对于用户程序来说，它其实你只要让它能够访问到我跟你说那个区域上就行了，每次你可以告诉这个系统它外部需要什么东西的时候，他就把内存的高级位变一下，就可以换到另一个区域去了，然后有一个区域是始终有一个区域是始终受限的共享这样。
说话人1 43:33
原文：
他不是还不只是全局变量，就是我们一般不提倡使用全局变量对吧？为什么说不提倡使用全局变量？因为全局变量它总会有一些数据不一致这种风险，比如说你有两个线程同时去读写一个全局变量，可能会引发一些很意外的东西。
说话人1 43:52
原文：
然后同时第三部分我们系统还要去实现同步多线程的同步锁信号量，这些东西不用很简单，单核系统上这事情都简单，
说话人3 44:02
原文：
他单位上他都包简单点是吧？
说话人2 44:05
原文：
好，
说话人1 44:06
原文：
单核系统它其实是最简单的，因为它不需要考虑到两个核心之间可能还会存在竞争，
说话人2 44:11
原文：
他没有你知道什么理由对吧？我看我专业。
说话人1 44:15
原文：
这些东西在系统内核里就是一个变量，就是一个不你给他付个一他就锁上了，付个0就没锁上，就这么简单。是这个部分。
说话人1 44:24
原文：
还有一个问题就是对外设的管理，你需要使用外设的时候，你需要先让系统形成一个告诉系统，就原则上来说其实你什么外设你都可以直接访问的，但是你为了要保证这个系统还是能够不避免不同的线程，错误的使用了同一个外设，那么我们需要告诉的系统说你用了这个东西然后去用就行了，那么系统在别人要用的时候，它就会返回一个失败，并且告诉他这个资源已经被占用了。
说话人1 44:50
原文：
所以基本的思路就是这样，我们现在第一阶段我们把这个做出来，其实我觉得不搞多片的。
说话人3 44:58
原文：
总裁都有，
说话人1 45:00
原文：
你要搞多片的走上天花的事情，我们再加上一个网络支持，我们可以支持烧给自己，
说话人2 45:05
原文：
弄得很好，不一定是要搞一些，所以兄弟的消费的其实还好，
说话人1 45:11
原文：
你不一定要烧给你可以做成假的，烧开才你懂，比如说三个q括号芯片号、逗号、线程号，逗号你的数据我。
说话人3 45:19
原文：
什么科研收入也好，可以这样做。
说话人1 45:21
原文：
等等这两一对函数，然后当你发过去之后，对方单位将触发一个中断系统，知道有这件事就调动给线到线说你有条新消息，然后把这个数据拷贝到它的内存区域，然后现场调用一个VC，那么系统就会把系从系统缓冲区里面复制到他那里去，到他又有消息了，然后你就做就行了。
说话人1 45:41
原文：
就是这么简单，然后顺便你可以发回来告诉他有这回事，你就收到一个回执告诉。
说话人2 45:47
原文：
你发过去，对方已经拿到了，就是这样子。
说话人2 45:50
原文：
现在看不了了，突然在做一些亲密的事情。
说话人1 45:55
原文：
差不多情况是这样子，其实这个事情。
说话人2 46:01
原文：
你知道单核系统怎么讲，懂了吗？最。
说话人1 46:05
原文：
恶心的是那些多核的恶心。
说话人3 46:08
原文：
你那以后用户就只能在固定的单核内存了，但是如果以后用户想用任意一片芯片，比如说想7片芯片。
说话人1 46:18
原文：
可以不是这个没问题，我们现在想尽量让芯片结，我觉得他们中间只有固定的简单的通信，我不太想做原来我们想的复杂的多芯片，还有通过msmc连接的，因为我发现就是fsmc更好的用途，其实拿来做限制切换，我们就不把它拿来。
说话人3 46:38
原文：
做，我们现在做的只是一个单芯片，不是做多。
说话人1 46:41
原文：
芯片的，但是每个芯片都有连接的芯片的能力，有一个思维去。
说话人2 46:45
原文：
把他们的数据进行连接，就模拟一个网络的概念。
说话人3 46:49
原文：
懂吧？老师每个芯片为什么每个芯片都是96k加1的？
说话人3 46:57
原文：
96k加1兆的，对。
说话人3 46:59
原文：
每个芯片上都有一个系统，每个芯片都是相同的，每个芯片都有一个系统，对都有一个系统。
说话人1 47:07
原文：
是的，都有一个系统。
说话人1 47:09
原文：
在它们之间在芯片之间，它们互相看起来都是对的，你要在一芯片里面完成信号发送和多面性的完成信号，我们尽量接口统一起来，比如说你刚不是有个三处，那么你在第一个参数里面不是要传芯片号吗？
说话人1 47:26
原文：
如果你就想传给本地的，你传个负一，知道要传给这一片的，以后你就可以共用一个东西，那么在程序看来，他们从接口上这一头看来他们其实都是一样的，知道吧？其实这就比较已经实现了假的，就是在程序看来并不知道自己运行在哪一片，没关系，反正发布信息都是一样的，然后比如说你可以发送给-1这边，今天如果你发送给的是-1逗号-1，那么就是发送给当时经常所有建筑，如果你发送的是-2-1，那就发送给所有芯片的所有权人，知道吧？就是类似这种。
说话人1 48:04
原文：
那么对于一个芯片来说，它其实看起来它是对一个限制方面其实是不变的一样，它不用去在意这些限制范围好在哪个具体的芯片上。
说话人3 48:12
原文：
理论上来说我们通过能不能实现任意数量，不仅是原来的8个，也是任意数量一样多就多少，但是这样会不会导致比如说某2个芯片还在运行，但是其他7个芯片都空下来了，
说话人1 48:26
原文：
空前是芯片是芯片的问题，它风险的问题。
说话人3 48:31
原文：
谁知到了为什么我们不能把这两个芯片的正常放到其他芯片上跑，就把有一个。
说话人1 48:38
原文：
问题，但毕竟还有外设，你外设应该接到上面去其实有点不好意思，
说话人3 48:44
原文：
但是这样实现了会充分发挥它的性能。
说话人3 48:48
原文：
对，当然这个是后续改进的一个思路，就是你先把这个做好，因为现在我们实际上还是虽然多芯片之间的问题，通信，但是其实芯片之间通信并没有什么用，怎么没有什么用，起到什么作用？
说话人1 49:04
原文：
两个芯片之间通信这个作用还不明显吗？
说话人3 49:08
原文：
我说对于我们的对我们的咱们现在不同芯片之间通讯刚才讲了，
说话人3 49:21
原文：
一开始构想就是说我没有那种。
说话人1 49:24
原文：
可以通过。
说话人3 49:25
原文：
不同声音连接了吗？
说话人3 49:28
原文：
大量的任务出发的不同芯片这个可以做，那么以前首先第一次我芯片收到了一份钻石，
说话人1 49:36
原文：
每一个任务在每个芯片里都有一个。
说话人3 49:39
原文：
我说的任务是指那个函数，不是这种原因，就不是说这个任务。
说话人1 49:45
原文：
理论上有一个片外的存储器，你需要一个你的片外存储器不是一个任务，你要调动的时候，你再把这个东西整体的搬迁到另一个层面上，你可以通过一个哈佛实现芯片访问那几位高地之类的时候，访问的是芯片或者高速什么或者其实下一步因为它需要外部产品规模很大，你想每个芯片都有十几条数据线，十几条地址线，每个芯片都要连到其他芯片，所有芯片都要有一份，这个的话信号线的数量就特别大，所以的话我们暂时不做，但是我们保留直接你可以。
说话人2 50:22
原文：
在机场晚上说先做出来，你现在再说对吧？
说话人2 50:27
原文：
你不要一下子如果压力太高，然后。
说话人1 50:30
原文：
走路也不方便对吧？你必须把这目标定成就一个芯片上做独者程已经算个很有意思的东西了是吧？先把它做了吧，然后我们看时间如果有可能我再把电路改一下变更一下，
说话人2 50:41
原文：
这也是他的，但是还有一个地方，除了刚才我说的很简单的，就是基于数据包的方式之外，我们还希望做一个。
说话人3 50:49
原文：
所有的心态梦想片片外那种就是内存不是用来传递的，但我现在还有一种单芯片上独占，我们有很独罩成的都可以用，
说话人2 50:59
原文：
那不是担心那样多项产品，你知道我们像这样子这么复杂的负面的，
说话人3 51:07
原文：
但是还有比如说这一撇出你放这里面那个房子可能就我说能，但他不是他的处理器不是MC优化，
说话人2 51:20
原文：
一个城市的他是MP优化，就是有内存管理单元的，那就是一个完整的跟个人电脑差不多的车，
说话人1 51:28
原文：
不是MC在我们这种比较有限的资源上能做成这样子算好，我看过很多那些你可能觉得比较老的什么rtrtos垃圾快就人老了，
说话人2 51:40
原文：
想办法做不到我们怎么去充分，包括s它运行在内存上，
说话人1 51:49
原文：
对os是直接使用天内存就96天。
说话人2 51:54
原文：
或者有什么样的是一个叫劳务调查。
说话人2 51:58
原文：
没事，他如果那就是一个上面确实好不好，然后掉了。
说话人1 52:07
原文：
不过我刚才说的我们跟那些东西还有一个最好的东西，就是我们支持多个芯片，包括芯片，我们说第一步，首先你用串口给我跑通通信线，然后第二部分你先用串口把通信跑通，串口都跑不通，你还想什么别的肯定不行。
说话人1 52:24
原文：
第二部分就是共享内存，所有芯片的共享片，比如说一兆的内存，所有的芯片通过sfsmc都能看到这些内存的存在，也都能访问它，这是第二部分，能做到这一步之后，那么首先我们能说明一件事情就是说大块的数据的那种存储，你可以直接用这芯片需要之前说的那种东西。
说话人1 52:47
原文：
第三步才是说把这个产品把任务从一片上丢到另一片上的东西，因为首先他们的外设是独立的，就芯片连的，比如说芯片连到一个电动机，芯片连到别的电动机把它换过去之后，你能直接用吗？那肯定不能对不对？如果这些芯片是只做计算的，你那个方案才能行得通，他们只不用任何外设，只是单纯拿来做计算，你这个确实是可以做的，现在这个方案改一改也是没有问题。
说话人3 53:13
原文：
的，因为我想我不是太了解硬件，比如我们去年 logo机械臂它是有个单片机的，那个单品就可以用来计算，
说话人1 53:26
原文：
可以正常来说你稍微资源多一点，你别搞那么资源那么小的，一个个都是紧凑的要死，放不进去什么东西你也不看。
说话人3 53:34
原文：
我们那种机械臂的单片机它大概是什么样的资源？
说话人2 53:40
原文：
机械臂单片机就跟你说8051都不起来，如果你跟我说80518051是什么？
说话人3 53:46
原文：
就那种特别老古董的，我会用那个东西，8051有多你的资源有多匮乏吗？
说话人1 53:52
原文：
内存4k代码空间几十k甚至更老的8051，代码空间只有4k内存只有256个字节，
说话人2 54:03
原文：
对，
说话人1 54:07
原文：
然后8位单片机它只有 l所有的内部都是8位的内存最大寻址能力是64k然后大量的依赖集成器也没有sm三有这么高级的外设，主频一般只有10个兆十几个兆这样子，但你不能否认的是大面积一直卖到现在还有，而且是量还相当不小，是非常成功的设计。
说话人1 54:31
原文：
这个上面甚至都有os，
说话人2 54:34
原文：
256字节上的他们服务自己怎么跑都有os， os是外围d吗？
说话人1 54:41
原文：
你说话了，他们好像也要实现简单的东西，但是肯定是没有调度，没有可能达标的，但是确实因为我有一次在 k5里面看到我这么个。
说话人2 54:51
原文：
东西，已经有一部分商业是吧？
说话人2 54:54
原文：
可能我刚才也对，如果你整个玩具我全都跑来，现在在这里交通，然后他不管这个问题，他完了什么都跑了，有些事情上来之前他的工作有那么重要，你看看指标版的多少了，那么就相当于昨天人民币然后什么是多少，我这一个大内存，然后我os在内存里面，然后我就调多个CPU，它的原点非常多的CPU，因为这里面的内容电脑方法来做一个东西，其实我的意思多少钱不多，就是一个CPU里面我说不是也是一个核没区别，我的意思是好好不说咱的用苹果电脑的一个CPU里多个，然后对我只需要我 os跑在内存里面，我就可以通过os作用来实现多个核子里，对是的，你看刚才说有个啥问题，公司电话了之后消耗钱了，多和之间的竞争对我认为只要做好每个回来隔离不就但是他们学生的能力的多，就是读者能力就是高兴是但问题是有的时候你会存在两个合同还是原数据怎么办？
说话人2 56:18
原文：
我说的是不需要，然后几个控制为啥？
说话人2 56:24
原文：
很简单，我只需要把内存划好几对吧？几块专用的几块空，然后还有一块os这样就可以了。
说话人1 56:36
原文：
问题不用的系统有很大的。
说话人2 56:38
原文：
因为他想说有任何可能你再说公用，我可以把公司也推到外，不是共用，不是os，现在从新的购物。
说话人2 56:51
原文：
我的意思就是说我os对你刚才说的就是os来控制，你不能指望我们就相当于os的一个互动里面的记录，然后如果有效的是这样。
说话人2 57:03
原文：
对我去了那种，反正我说的意思就是因为他要他们的资产都不敢玩，他肯定每个人都在这里，然后咱们主要是项目信息，你要不要看看说什么不对债？
说话人2 57:18
原文：
没有。
说话人2 57:19
原文：
它不是完整的，对，然后我如果对于咱们这个来说，我是不是可以把某一个完全相关的，如果真的有一个比较关心的话，我是不是直接去你要再怎么样？
说话人2 57:35
原文：
我把完全考虑一个问题目标，然后你这个合作，然后我用这个壳来调版的，进行管道贴上去调出来，我以这个壳的 os这样的对吧？
说话人2 57:49
原文：
反正相当于我刚才说的，然后我们现在然后一定要通过我就牺牲这个壳，让他都走了，然后别的部门去考虑一个，这样相当于就这样不就跟现在变成了
说话人1 58:09
原文：
现在一般不这么做，os跑在哪个地方其实都能预测，
说话人2 58:13
原文：
然后控制它是最后发行以后挫伤确实，但是我觉得叫教育的五官也要养。
说话人2 58:24
原文：
他只是是因为主要是什么？
说话人2 58:26
原文：
他主要我只需要让帮om进行一个计算的，因为你os进行的时候，别的线别的技术都会被暂停。
说话人2 58:37
原文：
不是的，因为中间也可以控制，不是的，现在我还是不知道，如果你是符合系统的话问题是吧？你。
说话人1 58:45
原文：
刚才说单核系统，刚才同样 os一旦就行了，因为同时能运行一个东西，你os运行，其他东西肯定不能运行，
说话人2 58:51
原文：
两个一起操作。那么你我总感觉我专门挑一个来运作，这样效率更好。
说话人3 59:02
原文：
不行，这一个用时间很短，然后最后另一个用户他不知道哪个上面应该运行你知道。
说话人1 59:09
原文：
吧？
说话人1 59:10
原文：
Os会帮你安排好核心的对。
说话人2 59:13
原文：
我知道对我是专门新用户，我就专门我拿这个东西专门好玩，
说话人1 59:17
原文：
你os的其实调用的时间很短，有的用户可能跑100秒，os还跑一秒，你如果全给os不行浪费。
说话人2 59:23
原文：
但是我的意思就是说我这么做相当于手续综合的那种通信，
说话人1 59:34
原文：
你怎么知道？
说话人2 59:35
原文：
因为他们一般都需要从新的存储处理系统运行，几百个现场不管怎么样一定不需要。
说话人1 59:43
原文：
你不可能说10个核心的系统，我的意思。
说话人2 59:45
原文：
就是我专门新出来1个专门就是你们所有东西都从我这走，你看通信是现成自己发起的，跟超前无关，不是你通信你得把信息就我的意思你把信息传我再发给别的，你说我相当于谁知一份消息都是那个人就更加大的市场，
说话人1 01:00:05

原文：
你要说最快的始终是两个点对点，直接发送肯定是一样的，
说话人2 01:00:12
原文：
因为10分钟了没有麻烦，你看他有一点我查有毒，我看我的房子不让你用了。
说话人3 01:00:21
原文：
然后我知道我手机上有多少是你宿舍不知道，
说话人2 01:00:26
原文：
 IP。
说话人3 01:00:29
原文：
是14。
说话人1 01:00:31
原文：
14，现在看起来是34分，是的。来吧，114的话校外不能叫啥，你要联系科大网上。
说话人3 01:00:38
原文：
这么长还都这么。
说话人1 01:00:40
原文：
是连一定要连续是吧？
说话人2 01:00:43
原文：
谢谢。
说话人2 01:00:45
原文：
把录音停了，差不多了。
说话人3 01:00:54
原文：
一会儿我把手机内存要爆了。