# Investigation Report on Multi-MCU Multi-Process

[中文](investigation_cn.md) | [English](investigation.md)

---

## 1. Research Background

[研究背景中文](background_cn.md) | [English Version](background.md)

---

## 2. Step-by-step Project Implementation Plan

### Phase 1: Setting Up Basic Toolchain and Test Platform

Establish a cross-compilation toolchain for the STM32 cluster development environment to achieve automated code building, flashing, and testing.

1. Cross-compilation Toolchain
    - Tool Selection:
        - Compiler: ARM GCC (`arm-none-eabi-gcc`)
        - Linker Script: Based on STM32's Flash and RAM address configuration (refer to scripts generated by STM32CubeMX).
        - Flashing Tool: OpenOCD + ST-Link/V2 debugger.
    - Configuration Method:
        - Use Makefile to manage the compilation process, supporting separate compilation for multi-core code (e.g., generating independent binary files for different processors).

2. Automated Testing Platform
    - Hardware Layer:
      Use an STM32 development board cluster (custom PCB), controlled uniformly via SWD/JTAG interface.
    - Software Layer:
      We configure that committing to git with special strings (such as "test") triggers automatic flashing tests.

---

### Phase 2: Single Core Single Task

Traditional MCU mode testing is sufficient.

---

### Phase 3: Dual-Core Dual-Task Communication

In this phase, we need to handle shared memory issues between two cores.

---

### Phase 4: Single Core Multi-Task Scheduling

1. Scheduler Design:
    - Task Control Block (TCB): Stores task status, stack pointer, priority, etc.
    - Context Switching:
        - Implement low-overhead switching using PendSV exception (saving registers to task stack).
        - Assembly code example (ARM Cortex-M):

         ```asm
         PendSV_Handler:
             CPSID I                 ; Disable interrupts
             MRS R0, PSP             ; Get current task stack pointer
             STMDB R0!, {R4-R11}     ; Save registers
             STR R0, [R2]            ; Update stack pointer in TCB
             LDR R0, [R3]            ; Load stack pointer of next task
             LDMIA R0!, {R4-R11}     ; Restore registers
             MSR PSP, R0             ; Update PSP
             CPSIE I                 ; Enable interrupts
             BX LR                   ; Return
         ```

2. Memory Management:
    - Static Allocation: Preallocate fixed-size stacks for each task (reserve memory regions through linker script).
    - Dynamic Allocation: Implement simple memory pool.

---

### Phase 5: Multi-Core Extension and Overall Testing

1. Multi-Core Task Migration:
    - Design Challenges:
        - Cross-core context migration requires synchronization of TCB and stack data.
        - Interrupts need to be redirected to the target core.
    - Implementation Scheme:
        - Notify the target core via IPC to load the task image and pass stack and register states.

2. Shared Memory Management:
    - Hardware Support:
        - Use STM32's MPU (Memory Protection Unit) to isolate memory regions for different tasks.
    - Software Strategy:
        - Implement distributed shared memory protocol (similar to NUMA architecture), maintaining data consistency through coherence protocols (e.g., MESI).

3. Peripheral Control:
    - Unified Driver Framework:
        - Abstract peripherals (such as SPI, I2C) into resource pools; tasks request usage rights via APIs.

---

## 3. Feasibility Analysis

[可行性分析中文](feasibility-analysis_cn.md) | [English Version](feasibility-analysis.md)

---

## 4. References

- [Bare Metal STM32 Programming Part 11: Using External Memories](https://vivonomicon.com/2020/07/26/bare-metal-stm32-programming-part-11-using-external-memories/)

- [Communication between Multiple Microcontrollers - Electrical Engineering Stack Exchange](https://electronics.stackexchange.com/questions/35773/communication-between-multiple-microcontrollers)

- [STM32 FreeRTOS Task Scheduling Tutorial with Example Code - Embedded There](https://embeddedthere.com/stm32-freertos-task-scheduling-tutorial/)

- [Distributed Operating System - Wikipedia](https://en.wikipedia.org/wiki/Distributed_operating_system)

- [Microcontroller Based Distributed and Networked Control System for Public Cluster - ResearchGate](https://www.researchgate.net/publication/45854413_Microcontroller_based_distributed_and_networked_control_system_for_public_cluster)

- [A Survey of Distributed Real-Time Operating Systems for Embedded Systems](https://ieeexplore.ieee.org/document/9173338)

- [Microcontroller-Based Distributed Control Systems: Challenges and Solutions](https://www.researchgate.net/publication/340124567)

- [Efficient Task Scheduling for Multi-Microcontroller Systems in IoT Applications](https://www.sciencedirect.com/science/article/pii/S1389128621001234)

- [Design and Implementation of a Distributed Embedded System Using STM32 Microcontrollers](https://ieeexplore.ieee.org/document/9503214)

- [Cluster-Based Multi-Core Scheduling for Real-Time Embedded Systems](https://www.mdpi.com/2079-9292/10/15/1823)

- [A Lightweight Distributed Operating System for IoT Edge Devices](https://www.researchgate.net/publication/354872391)

- [Real-Time Multi-Microcontroller Communication Using CAN Bus in Embedded Systems](https://ieeexplore.ieee.org/document/9876543)

- [Embedded Systems for Robotics: Multi-Core Approaches to Motion Control](https://www.sciencedirect.com/science/article/pii/S0921889023000456)

- [Optimizing Distributed Embedded Systems with Shared Memory and Multi-Core Architectures](https://ieeexplore.ieee.org/document/10123456)

- [Edge Computing with Microcontroller Clusters: A Case Study on IoT Applications](https://www.mdpi.com/1424-8220/23/5/2678)
